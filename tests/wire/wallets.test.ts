/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool";
import { StonfiClient } from "../../src/Client";

describe("Wallets", () => {
    test("get_wallet_assets", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            asset_list: [
                {
                    balance: "balance",
                    blacklisted: true,
                    community: true,
                    contract_address: "contract_address",
                    custom_payload_api_uri: "custom_payload_api_uri",
                    decimals: 1,
                    default_symbol: true,
                    deprecated: true,
                    dex_price_usd: "dex_price_usd",
                    dex_usd_price: "dex_usd_price",
                    display_name: "display_name",
                    extensions: ["extensions"],
                    image_url: "image_url",
                    kind: "Jetton",
                    popularity_index: 1.1,
                    priority: 1,
                    symbol: "symbol",
                    tags: ["tags"],
                    taxable: true,
                    third_party_price_usd: "third_party_price_usd",
                    third_party_usd_price: "third_party_usd_price",
                    wallet_address: "wallet_address",
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/v1/wallets/addr_str/assets")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.wallets.getWalletAssets("addr_str");
        expect(response).toEqual({
            asset_list: [
                {
                    balance: "balance",
                    blacklisted: true,
                    community: true,
                    contract_address: "contract_address",
                    custom_payload_api_uri: "custom_payload_api_uri",
                    decimals: 1,
                    default_symbol: true,
                    deprecated: true,
                    dex_price_usd: "dex_price_usd",
                    dex_usd_price: "dex_usd_price",
                    display_name: "display_name",
                    extensions: ["extensions"],
                    image_url: "image_url",
                    kind: "Jetton",
                    popularity_index: 1.1,
                    priority: 1,
                    symbol: "symbol",
                    tags: ["tags"],
                    taxable: true,
                    third_party_price_usd: "third_party_price_usd",
                    third_party_usd_price: "third_party_usd_price",
                    wallet_address: "wallet_address",
                },
            ],
        });
    });

    test("get_wallet_asset", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            asset: {
                balance: "balance",
                blacklisted: true,
                community: true,
                contract_address: "contract_address",
                custom_payload_api_uri: "custom_payload_api_uri",
                decimals: 1,
                default_symbol: true,
                deprecated: true,
                dex_price_usd: "dex_price_usd",
                dex_usd_price: "dex_usd_price",
                display_name: "display_name",
                extensions: ["extensions"],
                image_url: "image_url",
                kind: "Jetton",
                popularity_index: 1.1,
                priority: 1,
                symbol: "symbol",
                tags: ["tags"],
                taxable: true,
                third_party_price_usd: "third_party_price_usd",
                third_party_usd_price: "third_party_usd_price",
                wallet_address: "wallet_address",
            },
        };
        server
            .mockEndpoint()
            .get("/v1/wallets/addr_str/assets/asset_str")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.wallets.getWalletAsset("addr_str", "asset_str");
        expect(response).toEqual({
            asset: {
                balance: "balance",
                blacklisted: true,
                community: true,
                contract_address: "contract_address",
                custom_payload_api_uri: "custom_payload_api_uri",
                decimals: 1,
                default_symbol: true,
                deprecated: true,
                dex_price_usd: "dex_price_usd",
                dex_usd_price: "dex_usd_price",
                display_name: "display_name",
                extensions: ["extensions"],
                image_url: "image_url",
                kind: "Jetton",
                popularity_index: 1.1,
                priority: 1,
                symbol: "symbol",
                tags: ["tags"],
                taxable: true,
                third_party_price_usd: "third_party_price_usd",
                third_party_usd_price: "third_party_usd_price",
                wallet_address: "wallet_address",
            },
        });
    });

    test("get_wallet_farms", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            farm_list: [
                {
                    all_rewards_distributed: true,
                    apy: "apy",
                    create_timestamp: "2024-01-15T09:30:00Z",
                    custodian_address: "custodian_address",
                    locked_total_lp: "locked_total_lp",
                    locked_total_lp_usd: "locked_total_lp_usd",
                    min_stake_duration_s: "min_stake_duration_s",
                    minter_address: "minter_address",
                    nft_infos: [
                        {
                            address: "address",
                            create_timestamp: "create_timestamp",
                            min_unstake_timestamp: "min_unstake_timestamp",
                            nonclaimed_rewards: "nonclaimed_rewards",
                            rewards: [{ address: "address", amount: "amount" }],
                            staked_tokens: "staked_tokens",
                            status: "status",
                        },
                    ],
                    owner_address: "owner_address",
                    pool_address: "pool_address",
                    rewards: [
                        {
                            address: "address",
                            admin_fee: "admin_fee",
                            index: 1,
                            remaining_rewards: "remaining_rewards",
                            reward_rate_24h: "reward_rate_24h",
                            rewards_distributed: true,
                            status: "status",
                        },
                    ],
                    status: "status",
                    version: "version",
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/v1/wallets/addr_str/farms")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.wallets.getWalletFarms("addr_str");
        expect(response).toEqual({
            farm_list: [
                {
                    all_rewards_distributed: true,
                    apy: "apy",
                    create_timestamp: "2024-01-15T09:30:00Z",
                    custodian_address: "custodian_address",
                    locked_total_lp: "locked_total_lp",
                    locked_total_lp_usd: "locked_total_lp_usd",
                    min_stake_duration_s: "min_stake_duration_s",
                    minter_address: "minter_address",
                    nft_infos: [
                        {
                            address: "address",
                            create_timestamp: "create_timestamp",
                            min_unstake_timestamp: "min_unstake_timestamp",
                            nonclaimed_rewards: "nonclaimed_rewards",
                            rewards: [
                                {
                                    address: "address",
                                    amount: "amount",
                                },
                            ],
                            staked_tokens: "staked_tokens",
                            status: "status",
                        },
                    ],
                    owner_address: "owner_address",
                    pool_address: "pool_address",
                    rewards: [
                        {
                            address: "address",
                            admin_fee: "admin_fee",
                            index: 1,
                            remaining_rewards: "remaining_rewards",
                            reward_rate_24h: "reward_rate_24h",
                            rewards_distributed: true,
                            status: "status",
                        },
                    ],
                    status: "status",
                    version: "version",
                },
            ],
        });
    });

    test("get_wallet_farm", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            farm: {
                all_rewards_distributed: true,
                apy: "apy",
                create_timestamp: "2024-01-15T09:30:00Z",
                custodian_address: "custodian_address",
                locked_total_lp: "locked_total_lp",
                locked_total_lp_usd: "locked_total_lp_usd",
                meta: {
                    description: "description",
                    image: "image",
                    marketplace: "marketplace",
                    name: "name",
                    social_links: { key: "value" },
                },
                min_stake_duration_s: "min_stake_duration_s",
                minter_address: "minter_address",
                nft_infos: [
                    {
                        address: "address",
                        create_timestamp: "create_timestamp",
                        min_unstake_timestamp: "min_unstake_timestamp",
                        nonclaimed_rewards: "nonclaimed_rewards",
                        rewards: [{ address: "address", amount: "amount" }],
                        staked_tokens: "staked_tokens",
                        status: "status",
                    },
                ],
                owner_address: "owner_address",
                pool_address: "pool_address",
                rewards: [
                    {
                        address: "address",
                        admin_fee: "admin_fee",
                        index: 1,
                        remaining_rewards: "remaining_rewards",
                        reward_rate_24h: "reward_rate_24h",
                        rewards_distributed: true,
                        status: "status",
                    },
                ],
                status: "status",
                version: "version",
            },
        };
        server
            .mockEndpoint()
            .get("/v1/wallets/addr_str/farms/farm_str")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.wallets.getWalletFarm("addr_str", "farm_str");
        expect(response).toEqual({
            farm: {
                all_rewards_distributed: true,
                apy: "apy",
                create_timestamp: "2024-01-15T09:30:00Z",
                custodian_address: "custodian_address",
                locked_total_lp: "locked_total_lp",
                locked_total_lp_usd: "locked_total_lp_usd",
                meta: {
                    description: "description",
                    image: "image",
                    marketplace: "marketplace",
                    name: "name",
                    social_links: {
                        key: "value",
                    },
                },
                min_stake_duration_s: "min_stake_duration_s",
                minter_address: "minter_address",
                nft_infos: [
                    {
                        address: "address",
                        create_timestamp: "create_timestamp",
                        min_unstake_timestamp: "min_unstake_timestamp",
                        nonclaimed_rewards: "nonclaimed_rewards",
                        rewards: [
                            {
                                address: "address",
                                amount: "amount",
                            },
                        ],
                        staked_tokens: "staked_tokens",
                        status: "status",
                    },
                ],
                owner_address: "owner_address",
                pool_address: "pool_address",
                rewards: [
                    {
                        address: "address",
                        admin_fee: "admin_fee",
                        index: 1,
                        remaining_rewards: "remaining_rewards",
                        reward_rate_24h: "reward_rate_24h",
                        rewards_distributed: true,
                        status: "status",
                    },
                ],
                status: "status",
                version: "version",
            },
        });
    });

    test("get_fee_vaults", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            vault_list: [
                {
                    asset_address: "asset_address",
                    balance: "balance",
                    router_address: "router_address",
                    vault_address: "vault_address",
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/v1/wallets/addr_str/fee_vaults")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.wallets.getFeeVaults("addr_str");
        expect(response).toEqual({
            vault_list: [
                {
                    asset_address: "asset_address",
                    balance: "balance",
                    router_address: "router_address",
                    vault_address: "vault_address",
                },
            ],
        });
    });

    test("get_wallet_operations_utoipa", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            operations: [
                {
                    asset0_info: {
                        blacklisted: true,
                        community: true,
                        contract_address: "contract_address",
                        decimals: 1,
                        default_symbol: true,
                        deprecated: true,
                        kind: "Jetton",
                        priority: 1,
                        symbol: "symbol",
                        tags: ["tags"],
                        taxable: true,
                    },
                    asset1_info: {
                        blacklisted: true,
                        community: true,
                        contract_address: "contract_address",
                        decimals: 1,
                        default_symbol: true,
                        deprecated: true,
                        kind: "Jetton",
                        priority: 1,
                        symbol: "symbol",
                        tags: ["tags"],
                        taxable: true,
                    },
                    operation: {
                        asset0_address: "asset0_address",
                        asset0_amount: "asset0_amount",
                        asset0_delta: "asset0_delta",
                        asset0_reserve: "asset0_reserve",
                        asset1_address: "asset1_address",
                        asset1_amount: "asset1_amount",
                        asset1_delta: "asset1_delta",
                        asset1_reserve: "asset1_reserve",
                        destination_wallet_address: "destination_wallet_address",
                        exit_code: "exit_code",
                        lp_fee_amount: "lp_fee_amount",
                        lp_token_delta: "lp_token_delta",
                        lp_token_supply: "lp_token_supply",
                        operation_type: "swap",
                        pool_address: "pool_address",
                        pool_tx_hash: "pool_tx_hash",
                        pool_tx_lt: 1000000,
                        pool_tx_timestamp: "pool_tx_timestamp",
                        protocol_fee_amount: "protocol_fee_amount",
                        referral_fee_amount: "referral_fee_amount",
                        router_address: "router_address",
                        success: true,
                        wallet_address: "wallet_address",
                        wallet_tx_hash: "wallet_tx_hash",
                        wallet_tx_lt: "wallet_tx_lt",
                        wallet_tx_timestamp: "wallet_tx_timestamp",
                    },
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/v1/wallets/addr_str/operations")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.wallets.getWalletOperationsUtoipa("addr_str", {
            since: "2023-06-01T12:34:56",
            until: "2023-06-02T23:59:59",
        });
        expect(response).toEqual({
            operations: [
                {
                    asset0_info: {
                        blacklisted: true,
                        community: true,
                        contract_address: "contract_address",
                        decimals: 1,
                        default_symbol: true,
                        deprecated: true,
                        kind: "Jetton",
                        priority: 1,
                        symbol: "symbol",
                        tags: ["tags"],
                        taxable: true,
                    },
                    asset1_info: {
                        blacklisted: true,
                        community: true,
                        contract_address: "contract_address",
                        decimals: 1,
                        default_symbol: true,
                        deprecated: true,
                        kind: "Jetton",
                        priority: 1,
                        symbol: "symbol",
                        tags: ["tags"],
                        taxable: true,
                    },
                    operation: {
                        asset0_address: "asset0_address",
                        asset0_amount: "asset0_amount",
                        asset0_delta: "asset0_delta",
                        asset0_reserve: "asset0_reserve",
                        asset1_address: "asset1_address",
                        asset1_amount: "asset1_amount",
                        asset1_delta: "asset1_delta",
                        asset1_reserve: "asset1_reserve",
                        destination_wallet_address: "destination_wallet_address",
                        exit_code: "exit_code",
                        lp_fee_amount: "lp_fee_amount",
                        lp_token_delta: "lp_token_delta",
                        lp_token_supply: "lp_token_supply",
                        operation_type: "swap",
                        pool_address: "pool_address",
                        pool_tx_hash: "pool_tx_hash",
                        pool_tx_lt: 1000000,
                        pool_tx_timestamp: "pool_tx_timestamp",
                        protocol_fee_amount: "protocol_fee_amount",
                        referral_fee_amount: "referral_fee_amount",
                        router_address: "router_address",
                        success: true,
                        wallet_address: "wallet_address",
                        wallet_tx_hash: "wallet_tx_hash",
                        wallet_tx_lt: "wallet_tx_lt",
                        wallet_tx_timestamp: "wallet_tx_timestamp",
                    },
                },
            ],
        });
    });

    test("get_wallet_pools", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            pool_list: [
                {
                    address: "address",
                    amp: "amp",
                    apy_1d: "apy_1d",
                    apy_30d: "apy_30d",
                    apy_7d: "apy_7d",
                    collected_token0_protocol_fee: "collected_token0_protocol_fee",
                    collected_token1_protocol_fee: "collected_token1_protocol_fee",
                    deprecated: true,
                    lp_account_address: "lp_account_address",
                    lp_balance: "lp_balance",
                    lp_fee: "lp_fee",
                    lp_price_usd: "lp_price_usd",
                    lp_total_supply: "lp_total_supply",
                    lp_total_supply_usd: "lp_total_supply_usd",
                    lp_wallet_address: "lp_wallet_address",
                    popularity_index: 1.1,
                    protocol_fee: "protocol_fee",
                    protocol_fee_address: "protocol_fee_address",
                    rate: "rate",
                    ref_fee: "ref_fee",
                    reserve0: "reserve0",
                    reserve1: "reserve1",
                    router_address: "router_address",
                    token0_address: "token0_address",
                    token0_balance: "token0_balance",
                    token1_address: "token1_address",
                    token1_balance: "token1_balance",
                    volume_24h_usd: "volume_24h_usd",
                    w0: "w0",
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/v1/wallets/addr_str/pools")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.wallets.getWalletPools("addr_str");
        expect(response).toEqual({
            pool_list: [
                {
                    address: "address",
                    amp: "amp",
                    apy_1d: "apy_1d",
                    apy_30d: "apy_30d",
                    apy_7d: "apy_7d",
                    collected_token0_protocol_fee: "collected_token0_protocol_fee",
                    collected_token1_protocol_fee: "collected_token1_protocol_fee",
                    deprecated: true,
                    lp_account_address: "lp_account_address",
                    lp_balance: "lp_balance",
                    lp_fee: "lp_fee",
                    lp_price_usd: "lp_price_usd",
                    lp_total_supply: "lp_total_supply",
                    lp_total_supply_usd: "lp_total_supply_usd",
                    lp_wallet_address: "lp_wallet_address",
                    popularity_index: 1.1,
                    protocol_fee: "protocol_fee",
                    protocol_fee_address: "protocol_fee_address",
                    rate: "rate",
                    ref_fee: "ref_fee",
                    reserve0: "reserve0",
                    reserve1: "reserve1",
                    router_address: "router_address",
                    token0_address: "token0_address",
                    token0_balance: "token0_balance",
                    token1_address: "token1_address",
                    token1_balance: "token1_balance",
                    volume_24h_usd: "volume_24h_usd",
                    w0: "w0",
                },
            ],
        });
    });

    test("get_wallet_pool", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            pool: {
                address: "address",
                amp: "amp",
                apy_1d: "apy_1d",
                apy_30d: "apy_30d",
                apy_7d: "apy_7d",
                collected_token0_protocol_fee: "collected_token0_protocol_fee",
                collected_token1_protocol_fee: "collected_token1_protocol_fee",
                deprecated: true,
                lp_account_address: "lp_account_address",
                lp_balance: "lp_balance",
                lp_fee: "lp_fee",
                lp_price_usd: "lp_price_usd",
                lp_total_supply: "lp_total_supply",
                lp_total_supply_usd: "lp_total_supply_usd",
                lp_wallet_address: "lp_wallet_address",
                popularity_index: 1.1,
                protocol_fee: "protocol_fee",
                protocol_fee_address: "protocol_fee_address",
                rate: "rate",
                ref_fee: "ref_fee",
                reserve0: "reserve0",
                reserve1: "reserve1",
                router_address: "router_address",
                token0_address: "token0_address",
                token0_balance: "token0_balance",
                token1_address: "token1_address",
                token1_balance: "token1_balance",
                volume_24h_usd: "volume_24h_usd",
                w0: "w0",
            },
        };
        server
            .mockEndpoint()
            .get("/v1/wallets/addr_str/pools/pool_str")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.wallets.getWalletPool("addr_str", "pool_str");
        expect(response).toEqual({
            pool: {
                address: "address",
                amp: "amp",
                apy_1d: "apy_1d",
                apy_30d: "apy_30d",
                apy_7d: "apy_7d",
                collected_token0_protocol_fee: "collected_token0_protocol_fee",
                collected_token1_protocol_fee: "collected_token1_protocol_fee",
                deprecated: true,
                lp_account_address: "lp_account_address",
                lp_balance: "lp_balance",
                lp_fee: "lp_fee",
                lp_price_usd: "lp_price_usd",
                lp_total_supply: "lp_total_supply",
                lp_total_supply_usd: "lp_total_supply_usd",
                lp_wallet_address: "lp_wallet_address",
                popularity_index: 1.1,
                protocol_fee: "protocol_fee",
                protocol_fee_address: "protocol_fee_address",
                rate: "rate",
                ref_fee: "ref_fee",
                reserve0: "reserve0",
                reserve1: "reserve1",
                router_address: "router_address",
                token0_address: "token0_address",
                token0_balance: "token0_balance",
                token1_address: "token1_address",
                token1_balance: "token1_balance",
                volume_24h_usd: "volume_24h_usd",
                w0: "w0",
            },
        });
    });

    test("get_wallet_stakes", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            minted_gemston: "minted_gemston",
            nfts: [
                {
                    address: "address",
                    image_url: "image_url",
                    min_unstaking_timestamp: "min_unstaking_timestamp",
                    minted_gemston: "minted_gemston",
                    staked_tokens: "staked_tokens",
                    staking_timestamp: "staking_timestamp",
                    status: "status",
                    unstake_timestamp: "unstake_timestamp",
                    voting_power: "voting_power",
                },
            ],
            staked_ston: "staked_ston",
            ston_balance: "ston_balance",
            voting_power: "voting_power",
        };
        server
            .mockEndpoint()
            .get("/v1/wallets/addr_str/stakes")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.wallets.getWalletStakes("addr_str");
        expect(response).toEqual({
            minted_gemston: "minted_gemston",
            nfts: [
                {
                    address: "address",
                    image_url: "image_url",
                    min_unstaking_timestamp: "min_unstaking_timestamp",
                    minted_gemston: "minted_gemston",
                    staked_tokens: "staked_tokens",
                    staking_timestamp: "staking_timestamp",
                    status: "status",
                    unstake_timestamp: "unstake_timestamp",
                    voting_power: "voting_power",
                },
            ],
            staked_ston: "staked_ston",
            ston_balance: "ston_balance",
            voting_power: "voting_power",
        });
    });
});
