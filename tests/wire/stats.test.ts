/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool";
import { StonfiClient } from "../../src/Client";

describe("Stats", () => {
    test("get_dex_stats", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            since: "since",
            stats: { trades: 1000000, tvl: "tvl", unique_wallets: 1000000, volume_usd: "volume_usd" },
            until: "until",
        };
        server.mockEndpoint().get("/v1/stats/dex").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.stats.getDexStats({
            since: "2023-06-01T12:34:56",
            until: "2023-06-02T23:59:59",
        });
        expect(response).toEqual({
            since: "since",
            stats: {
                trades: 1000000,
                tvl: "tvl",
                unique_wallets: 1000000,
                volume_usd: "volume_usd",
            },
            until: "until",
        });
    });

    test("get_fee_accruals_stats", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            operations: [
                {
                    asset0_address: "asset0_address",
                    asset0_amount: "asset0_amount",
                    asset0_delta: "asset0_delta",
                    asset0_reserve: "asset0_reserve",
                    asset1_address: "asset1_address",
                    asset1_amount: "asset1_amount",
                    asset1_delta: "asset1_delta",
                    asset1_reserve: "asset1_reserve",
                    destination_wallet_address: "destination_wallet_address",
                    exit_code: "exit_code",
                    fee_asset_address: "fee_asset_address",
                    lp_fee_amount: "lp_fee_amount",
                    lp_token_delta: "lp_token_delta",
                    lp_token_supply: "lp_token_supply",
                    operation_type: "swap",
                    pool_address: "pool_address",
                    pool_tx_hash: "pool_tx_hash",
                    pool_tx_lt: 1000000,
                    pool_tx_timestamp: "pool_tx_timestamp",
                    protocol_fee_amount: "protocol_fee_amount",
                    referral_address: "referral_address",
                    referral_fee_amount: "referral_fee_amount",
                    router_address: "router_address",
                    success: true,
                    wallet_address: "wallet_address",
                    wallet_tx_hash: "wallet_tx_hash",
                    wallet_tx_lt: "wallet_tx_lt",
                    wallet_tx_timestamp: "wallet_tx_timestamp",
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/v1/stats/fee_accruals")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.stats.getFeeAccrualsStats({
            referrer_address: "EQCwiRZrfUSlMM0dz-Hm4KW1IqaFz1Pwxg3-t0jQDt36qOar",
            since: "2025-04-01T12:00:00",
            until: "2025-04-03T13:00:00",
        });
        expect(response).toEqual({
            operations: [
                {
                    asset0_address: "asset0_address",
                    asset0_amount: "asset0_amount",
                    asset0_delta: "asset0_delta",
                    asset0_reserve: "asset0_reserve",
                    asset1_address: "asset1_address",
                    asset1_amount: "asset1_amount",
                    asset1_delta: "asset1_delta",
                    asset1_reserve: "asset1_reserve",
                    destination_wallet_address: "destination_wallet_address",
                    exit_code: "exit_code",
                    fee_asset_address: "fee_asset_address",
                    lp_fee_amount: "lp_fee_amount",
                    lp_token_delta: "lp_token_delta",
                    lp_token_supply: "lp_token_supply",
                    operation_type: "swap",
                    pool_address: "pool_address",
                    pool_tx_hash: "pool_tx_hash",
                    pool_tx_lt: 1000000,
                    pool_tx_timestamp: "pool_tx_timestamp",
                    protocol_fee_amount: "protocol_fee_amount",
                    referral_address: "referral_address",
                    referral_fee_amount: "referral_fee_amount",
                    router_address: "router_address",
                    success: true,
                    wallet_address: "wallet_address",
                    wallet_tx_hash: "wallet_tx_hash",
                    wallet_tx_lt: "wallet_tx_lt",
                    wallet_tx_timestamp: "wallet_tx_timestamp",
                },
            ],
        });
    });

    test("get_fee_withdrawals_stats", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            withdrawals: [
                {
                    amount: "amount",
                    asset_address: "asset_address",
                    exit_code: "exit_code",
                    operation_wallet_address: "operation_wallet_address",
                    router_address: "router_address",
                    success: true,
                    vault_address: "vault_address",
                    vault_tx_hash: "vault_tx_hash",
                    vault_tx_lt: 1000000,
                    vault_tx_timestamp: "2024-01-15T09:30:00Z",
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/v1/stats/fee_withdrawals")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.stats.getFeeWithdrawalsStats({
            referrer_address: "EQCwiRZrfUSlMM0dz-Hm4KW1IqaFz1Pwxg3-t0jQDt36qOar",
            since: "2025-04-01T12:00:00",
            until: "2025-04-03T13:00:00",
        });
        expect(response).toEqual({
            withdrawals: [
                {
                    amount: "amount",
                    asset_address: "asset_address",
                    exit_code: "exit_code",
                    operation_wallet_address: "operation_wallet_address",
                    router_address: "router_address",
                    success: true,
                    vault_address: "vault_address",
                    vault_tx_hash: "vault_tx_hash",
                    vault_tx_lt: 1000000,
                    vault_tx_timestamp: "2024-01-15T09:30:00Z",
                },
            ],
        });
    });

    test("get_fees_stats", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            assets_fee_stats: [
                {
                    accrued: "accrued",
                    accrued_usd: "accrued_usd",
                    asset_address: "asset_address",
                    withdrawn: "withdrawn",
                    withdrawn_usd: "withdrawn_usd",
                },
            ],
            since: "since",
            total_accrued_usd: "total_accrued_usd",
            total_withdrawn_usd: "total_withdrawn_usd",
            until: "until",
        };
        server.mockEndpoint().get("/v1/stats/fees").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.stats.getFeesStats({
            referrer_address: "EQCwiRZrfUSlMM0dz-Hm4KW1IqaFz1Pwxg3-t0jQDt36qOar",
            since: "2025-04-01T12:00:00",
            until: "2025-04-03T13:00:00",
        });
        expect(response).toEqual({
            assets_fee_stats: [
                {
                    accrued: "accrued",
                    accrued_usd: "accrued_usd",
                    asset_address: "asset_address",
                    withdrawn: "withdrawn",
                    withdrawn_usd: "withdrawn_usd",
                },
            ],
            since: "since",
            total_accrued_usd: "total_accrued_usd",
            total_withdrawn_usd: "total_withdrawn_usd",
            until: "until",
        });
    });

    test("get_operation_stats_utoipa", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            since: "since",
            stats: [
                {
                    apy: "apy",
                    base_id: "base_id",
                    base_liquidity: "base_liquidity",
                    base_name: "base_name",
                    base_symbol: "base_symbol",
                    base_volume: "base_volume",
                    last_price: "last_price",
                    lp_price: "lp_price",
                    lp_price_usd: "lp_price_usd",
                    pool_address: "pool_address",
                    quote_id: "quote_id",
                    quote_liquidity: "quote_liquidity",
                    quote_name: "quote_name",
                    quote_symbol: "quote_symbol",
                    quote_volume: "quote_volume",
                    router_address: "router_address",
                    url: "url",
                },
            ],
            unique_wallets_count: 1000000,
            until: "until",
        };
        server
            .mockEndpoint()
            .get("/v1/stats/operations")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.stats.getOperationStatsUtoipa({
            since: "2023-06-01T12:34:56",
            until: "2023-06-02T23:59:59",
        });
        expect(response).toEqual({
            since: "since",
            stats: [
                {
                    apy: "apy",
                    base_id: "base_id",
                    base_liquidity: "base_liquidity",
                    base_name: "base_name",
                    base_symbol: "base_symbol",
                    base_volume: "base_volume",
                    last_price: "last_price",
                    lp_price: "lp_price",
                    lp_price_usd: "lp_price_usd",
                    pool_address: "pool_address",
                    quote_id: "quote_id",
                    quote_liquidity: "quote_liquidity",
                    quote_name: "quote_name",
                    quote_symbol: "quote_symbol",
                    quote_volume: "quote_volume",
                    router_address: "router_address",
                    url: "url",
                },
            ],
            unique_wallets_count: 1000000,
            until: "until",
        });
    });

    test("get_pool_stats_utoipa", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            since: "since",
            stats: [
                {
                    apy: "apy",
                    base_id: "base_id",
                    base_liquidity: "base_liquidity",
                    base_name: "base_name",
                    base_symbol: "base_symbol",
                    base_volume: "base_volume",
                    last_price: "last_price",
                    lp_price: "lp_price",
                    lp_price_usd: "lp_price_usd",
                    pool_address: "pool_address",
                    quote_id: "quote_id",
                    quote_liquidity: "quote_liquidity",
                    quote_name: "quote_name",
                    quote_symbol: "quote_symbol",
                    quote_volume: "quote_volume",
                    router_address: "router_address",
                    url: "url",
                },
            ],
            unique_wallets_count: 1000000,
            until: "until",
        };
        server.mockEndpoint().get("/v1/stats/pool").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.stats.getPoolStatsUtoipa({
            since: "2023-06-01T12:34:56",
            until: "2023-06-02T23:59:59",
        });
        expect(response).toEqual({
            since: "since",
            stats: [
                {
                    apy: "apy",
                    base_id: "base_id",
                    base_liquidity: "base_liquidity",
                    base_name: "base_name",
                    base_symbol: "base_symbol",
                    base_volume: "base_volume",
                    last_price: "last_price",
                    lp_price: "lp_price",
                    lp_price_usd: "lp_price_usd",
                    pool_address: "pool_address",
                    quote_id: "quote_id",
                    quote_liquidity: "quote_liquidity",
                    quote_name: "quote_name",
                    quote_symbol: "quote_symbol",
                    quote_volume: "quote_volume",
                    router_address: "router_address",
                    url: "url",
                },
            ],
            unique_wallets_count: 1000000,
            until: "until",
        });
    });

    test("get_staking_stats", async () => {
        const server = mockServerPool.createServer();
        const client = new StonfiClient({ environment: server.baseUrl });

        const rawResponseBody = {
            gemston_total_supply: "gemston_total_supply",
            ston_price_usd: "ston_price_usd",
            ston_total_supply: "ston_total_supply",
            total_staked_ston: "total_staked_ston",
        };
        server.mockEndpoint().get("/v1/stats/staking").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.stats.getStakingStats();
        expect(response).toEqual({
            gemston_total_supply: "gemston_total_supply",
            ston_price_usd: "ston_price_usd",
            ston_total_supply: "ston_total_supply",
            total_staked_ston: "total_staked_ston",
        });
    });
});
