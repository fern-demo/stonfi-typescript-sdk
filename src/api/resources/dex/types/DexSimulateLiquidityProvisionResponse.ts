/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface DexSimulateLiquidityProvisionResponse {
    /** Expected LP tokens received at current pool rate */
    estimated_lp_units: string;
    /** Estimated token a rate after liquidity provision */
    estimated_token_a_rate: string;
    /** Estimated token a units */
    estimated_token_a_units: string;
    /** Estimated token b rate after liquidity provision */
    estimated_token_b_rate: string;
    /** Estimated token b units */
    estimated_token_b_units: string;
    /** Existing LP account address (only present if wallet_address was provided and account exists) */
    lp_account_address?: string;
    /** Current Token A balance in LP account (if applicable) */
    lp_account_token_a_balance?: string;
    /** Current Token B balance in LP account (if applicable) */
    lp_account_token_b_balance?: string;
    /**
     * Total LP tokens in pool after operation:
     * - Initial: Always "0" (new pool)
     * - Balanced: Existing supply + proportional share
     * - Arbitrary: Existing supply + calculated based on custom amounts
     */
    lp_total_supply: string;
    /** Minimum LP tokens guaranteed with slippage applied */
    min_lp_units: string;
    /** Minimum Token A amount guaranteed with slippage applied */
    min_token_a_units: string;
    /** Minimum Token B amount guaranteed with slippage applied */
    min_token_b_units: string;
    /** Pool address (newly computed for Initial, existing for Balanced and Arbitrary) */
    pool_address: string;
    /** Price impact of the liquidity operation, expressed as decimal fraction (e.g., 0.01 = 1%) */
    price_impact: string;
    /**
     * Type of provision executed:
     * - Initial: New pool creation
     * - Balanced: Ratio-maintained addition
     * - Arbitrary: Custom ratio addition
     */
    provision_type: string;
    /** Router contract handling the liquidity operation */
    router_address: string;
    /** First token in pair (matches request) */
    token_a: string;
    /** Final calculated amount of Token A being deposited */
    token_a_units: string;
    /** Second token in pair (matches request) */
    token_b: string;
    /** Final calculated amount of Token B being deposited */
    token_b_units: string;
}
