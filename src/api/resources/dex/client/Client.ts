/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as core from "../../../../core/index.js";
import * as Stonfi from "../../../index.js";
import { mergeHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace Dex {
    export interface Options {
        environment: core.Supplier<string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

/**
 * DEX operations and entities
 */
export class Dex {
    protected readonly _options: Dex.Options;

    constructor(_options: Dex.Options) {
        this._options = _options;
    }

    /**
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.getAssetList()
     */
    public getAssetList(requestOptions?: Dex.RequestOptions): core.HttpResponsePromise<Stonfi.GetAssetListResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getAssetList(requestOptions));
    }

    private async __getAssetList(
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.GetAssetListResponse>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/assets",
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.GetAssetListResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling GET /v1/assets.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.AssetQueryRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.assetQuery()
     */
    public assetQuery(
        request: Stonfi.AssetQueryRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.AssetQueryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__assetQuery(request, requestOptions));
    }

    private async __assetQuery(
        request: Stonfi.AssetQueryRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.AssetQueryResponse>> {
        const { condition, unconditional_asset: unconditionalAsset, wallet_address: walletAddress } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (condition !== undefined) {
            _queryParams["condition"] = condition;
        }

        if (unconditionalAsset != null) {
            if (Array.isArray(unconditionalAsset)) {
                _queryParams["unconditional_asset"] = unconditionalAsset.map((item) => item);
            } else {
                _queryParams["unconditional_asset"] = unconditionalAsset;
            }
        }

        if (walletAddress !== undefined) {
            _queryParams["wallet_address"] = walletAddress;
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/assets/query",
            ),
            method: "POST",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.AssetQueryResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling POST /v1/assets/query.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.AssetSearchRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.assetSearch({
     *         search_string: "search_string"
     *     })
     */
    public assetSearch(
        request: Stonfi.AssetSearchRequest,
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.AssetSearchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__assetSearch(request, requestOptions));
    }

    private async __assetSearch(
        request: Stonfi.AssetSearchRequest,
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.AssetSearchResponse>> {
        const {
            search_string: searchString,
            condition,
            unconditional_asset: unconditionalAsset,
            limit,
            wallet_address: walletAddress,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["search_string"] = searchString;
        if (condition !== undefined) {
            _queryParams["condition"] = condition;
        }

        if (unconditionalAsset != null) {
            if (Array.isArray(unconditionalAsset)) {
                _queryParams["unconditional_asset"] = unconditionalAsset.map((item) => item);
            } else {
                _queryParams["unconditional_asset"] = unconditionalAsset;
            }
        }

        if (limit !== undefined) {
            _queryParams["limit"] = limit?.toString() ?? null;
        }

        if (walletAddress !== undefined) {
            _queryParams["wallet_address"] = walletAddress;
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/assets/search",
            ),
            method: "POST",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.AssetSearchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling POST /v1/assets/search.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.GetAssetRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.getAsset({
     *         addr_str: "addr_str"
     *     })
     */
    public getAsset(
        request: Stonfi.GetAssetRequest,
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.GetAssetResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getAsset(request, requestOptions));
    }

    private async __getAsset(
        request: Stonfi.GetAssetRequest,
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.GetAssetResponse>> {
        const { addr_str: addrStr } = request;
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `v1/assets/${encodeURIComponent(addrStr)}`,
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.GetAssetResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling GET /v1/assets/{addr_str}.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.GetFarmListRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.getFarmList()
     */
    public getFarmList(
        request: Stonfi.GetFarmListRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.GetFarmListResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getFarmList(request, requestOptions));
    }

    private async __getFarmList(
        request: Stonfi.GetFarmListRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.GetFarmListResponse>> {
        const { dex_v2: dexV2, only_active: onlyActive } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (dexV2 !== undefined) {
            _queryParams["dex_v2"] = dexV2?.toString() ?? null;
        }

        if (onlyActive !== undefined) {
            _queryParams["only_active"] = onlyActive?.toString() ?? null;
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/farms",
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.GetFarmListResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling GET /v1/farms.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.GetFarmsByPoolRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.getFarmsByPool({
     *         pool_addr_str: "pool_addr_str"
     *     })
     */
    public getFarmsByPool(
        request: Stonfi.GetFarmsByPoolRequest,
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.GetFarmsByPoolResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getFarmsByPool(request, requestOptions));
    }

    private async __getFarmsByPool(
        request: Stonfi.GetFarmsByPoolRequest,
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.GetFarmsByPoolResponse>> {
        const { pool_addr_str: poolAddrStr } = request;
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `v1/farms/by_pool/${encodeURIComponent(poolAddrStr)}`,
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.GetFarmsByPoolResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError(
                    "Timeout exceeded when calling GET /v1/farms/by_pool/{pool_addr_str}.",
                );
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.GetFarmRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.getFarm({
     *         addr_str: "addr_str"
     *     })
     */
    public getFarm(
        request: Stonfi.GetFarmRequest,
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.GetFarmResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getFarm(request, requestOptions));
    }

    private async __getFarm(
        request: Stonfi.GetFarmRequest,
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.GetFarmResponse>> {
        const { addr_str: addrStr } = request;
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `v1/farms/${encodeURIComponent(addrStr)}`,
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.GetFarmResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling GET /v1/farms/{addr_str}.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.DexSimulateLiquidityProvisionRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.simulateLiquidityProvision({
     *         provision_type: "Initial",
     *         token_a: "EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c",
     *         token_b: "EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs",
     *         slippage_tolerance: "0.001"
     *     })
     */
    public simulateLiquidityProvision(
        request: Stonfi.DexSimulateLiquidityProvisionRequest,
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.DexSimulateLiquidityProvisionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__simulateLiquidityProvision(request, requestOptions));
    }

    private async __simulateLiquidityProvision(
        request: Stonfi.DexSimulateLiquidityProvisionRequest,
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.DexSimulateLiquidityProvisionResponse>> {
        const {
            provision_type: provisionType,
            pool_address: poolAddress,
            wallet_address: walletAddress,
            token_a: tokenA,
            token_b: tokenB,
            token_a_units: tokenAUnits,
            token_b_units: tokenBUnits,
            slippage_tolerance: slippageTolerance,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["provision_type"] = provisionType;
        if (poolAddress !== undefined) {
            _queryParams["pool_address"] = poolAddress;
        }

        if (walletAddress !== undefined) {
            _queryParams["wallet_address"] = walletAddress;
        }

        _queryParams["token_a"] = tokenA;
        _queryParams["token_b"] = tokenB;
        if (tokenAUnits !== undefined) {
            _queryParams["token_a_units"] = tokenAUnits;
        }

        if (tokenBUnits !== undefined) {
            _queryParams["token_b_units"] = tokenBUnits;
        }

        _queryParams["slippage_tolerance"] = slippageTolerance;
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/liquidity_provision/simulate",
            ),
            method: "POST",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Stonfi.DexSimulateLiquidityProvisionResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError(
                    "Timeout exceeded when calling POST /v1/liquidity_provision/simulate.",
                );
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.GetMarketListRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.getMarketList()
     */
    public getMarketList(
        request: Stonfi.GetMarketListRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.GetMarketListResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getMarketList(request, requestOptions));
    }

    private async __getMarketList(
        request: Stonfi.GetMarketListRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.GetMarketListResponse>> {
        const { dex_v2: dexV2 } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (dexV2 !== undefined) {
            _queryParams["dex_v2"] = dexV2?.toString() ?? null;
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/markets",
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.GetMarketListResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling GET /v1/markets.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.PoolQueryRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.poolQuery()
     */
    public poolQuery(
        request: Stonfi.PoolQueryRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.PoolQueryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__poolQuery(request, requestOptions));
    }

    private async __poolQuery(
        request: Stonfi.PoolQueryRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.PoolQueryResponse>> {
        const {
            condition,
            unconditional_asset: unconditionalAsset,
            wallet_address: walletAddress,
            dex_v2: dexV2,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (condition !== undefined) {
            _queryParams["condition"] = condition;
        }

        if (unconditionalAsset != null) {
            if (Array.isArray(unconditionalAsset)) {
                _queryParams["unconditional_asset"] = unconditionalAsset.map((item) => item);
            } else {
                _queryParams["unconditional_asset"] = unconditionalAsset;
            }
        }

        if (walletAddress !== undefined) {
            _queryParams["wallet_address"] = walletAddress;
        }

        if (dexV2 !== undefined) {
            _queryParams["dex_v2"] = dexV2;
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/pool/query",
            ),
            method: "POST",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.PoolQueryResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling POST /v1/pool/query.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.GetPoolListRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.getPoolList()
     */
    public getPoolList(
        request: Stonfi.GetPoolListRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.GetPoolListResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getPoolList(request, requestOptions));
    }

    private async __getPoolList(
        request: Stonfi.GetPoolListRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.GetPoolListResponse>> {
        const { dex_v2: dexV2 } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (dexV2 !== undefined) {
            _queryParams["dex_v2"] = dexV2?.toString() ?? null;
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/pools",
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.GetPoolListResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling GET /v1/pools.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.GetPoolListByMarketRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.getPoolListByMarket({
     *         asset_0_addr_str: "asset_0_addr_str",
     *         asset_1_addr_str: "asset_1_addr_str"
     *     })
     */
    public getPoolListByMarket(
        request: Stonfi.GetPoolListByMarketRequest,
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.GetPoolListByMarketResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getPoolListByMarket(request, requestOptions));
    }

    private async __getPoolListByMarket(
        request: Stonfi.GetPoolListByMarketRequest,
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.GetPoolListByMarketResponse>> {
        const { asset_0_addr_str: asset0AddrStr, asset_1_addr_str: asset1AddrStr } = request;
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `v1/pools/by_market/${encodeURIComponent(asset0AddrStr)}/${encodeURIComponent(asset1AddrStr)}`,
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.GetPoolListByMarketResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError(
                    "Timeout exceeded when calling GET /v1/pools/by_market/{asset_0_addr_str}/{asset_1_addr_str}.",
                );
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.GetPoolRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.getPool({
     *         addr_str: "addr_str"
     *     })
     */
    public getPool(
        request: Stonfi.GetPoolRequest,
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.GetPoolResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getPool(request, requestOptions));
    }

    private async __getPool(
        request: Stonfi.GetPoolRequest,
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.GetPoolResponse>> {
        const { addr_str: addrStr } = request;
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `v1/pools/${encodeURIComponent(addrStr)}`,
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.GetPoolResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling GET /v1/pools/{addr_str}.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.DexReverseSimulateSwapUtoipaRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.reverseSimulateSwapUtoipa({
     *         offer_address: "EQBynBO23ywHy_CgarY9NK9FTz0yDsG82PtcbSTQgGoXwiuA",
     *         ask_address: "EQCM3B12QK1e4yZSf8GtBRT0aLMNyEsBc_DhVfRRtOEffLez",
     *         units: "300",
     *         slippage_tolerance: "0.001"
     *     })
     */
    public reverseSimulateSwapUtoipa(
        request: Stonfi.DexReverseSimulateSwapUtoipaRequest,
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.DexReverseSimulateSwapUtoipaResponse> {
        return core.HttpResponsePromise.fromPromise(this.__reverseSimulateSwapUtoipa(request, requestOptions));
    }

    private async __reverseSimulateSwapUtoipa(
        request: Stonfi.DexReverseSimulateSwapUtoipaRequest,
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.DexReverseSimulateSwapUtoipaResponse>> {
        const {
            offer_address: offerAddress,
            ask_address: askAddress,
            units,
            slippage_tolerance: slippageTolerance,
            pool_address: poolAddress,
            referral_address: referralAddress,
            referral_fee_bps: referralFeeBps,
            dex_v2: dexV2,
            dex_version: dexVersion,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["offer_address"] = offerAddress;
        _queryParams["ask_address"] = askAddress;
        _queryParams["units"] = units;
        _queryParams["slippage_tolerance"] = slippageTolerance;
        if (poolAddress !== undefined) {
            _queryParams["pool_address"] = poolAddress;
        }

        if (referralAddress !== undefined) {
            _queryParams["referral_address"] = referralAddress;
        }

        if (referralFeeBps !== undefined) {
            _queryParams["referral_fee_bps"] = referralFeeBps;
        }

        if (dexV2 !== undefined) {
            _queryParams["dex_v2"] = dexV2?.toString() ?? null;
        }

        if (dexVersion != null) {
            if (Array.isArray(dexVersion)) {
                _queryParams["dex_version"] = dexVersion.map((item) => item);
            } else {
                _queryParams["dex_version"] = dexVersion;
            }
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/reverse_swap/simulate",
            ),
            method: "POST",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Stonfi.DexReverseSimulateSwapUtoipaResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling POST /v1/reverse_swap/simulate.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.GetRouterListRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.getRouterList()
     */
    public getRouterList(
        request: Stonfi.GetRouterListRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.GetRouterListResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getRouterList(request, requestOptions));
    }

    private async __getRouterList(
        request: Stonfi.GetRouterListRequest = {},
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.GetRouterListResponse>> {
        const { dex_v2: dexV2 } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (dexV2 !== undefined) {
            _queryParams["dex_v2"] = dexV2?.toString() ?? null;
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/routers",
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.GetRouterListResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling GET /v1/routers.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.GetRouterRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.getRouter({
     *         addr_str: "addr_str"
     *     })
     */
    public getRouter(
        request: Stonfi.GetRouterRequest,
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.GetRouterResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getRouter(request, requestOptions));
    }

    private async __getRouter(
        request: Stonfi.GetRouterRequest,
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.GetRouterResponse>> {
        const { addr_str: addrStr } = request;
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `v1/routers/${encodeURIComponent(addrStr)}`,
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.GetRouterResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling GET /v1/routers/{addr_str}.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.DexSimulateSwapUtoipaRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.simulateSwapUtoipa({
     *         offer_address: "EQBynBO23ywHy_CgarY9NK9FTz0yDsG82PtcbSTQgGoXwiuA",
     *         ask_address: "EQCM3B12QK1e4yZSf8GtBRT0aLMNyEsBc_DhVfRRtOEffLez",
     *         units: "300",
     *         slippage_tolerance: "0.001"
     *     })
     */
    public simulateSwapUtoipa(
        request: Stonfi.DexSimulateSwapUtoipaRequest,
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.DexSimulateSwapUtoipaResponse> {
        return core.HttpResponsePromise.fromPromise(this.__simulateSwapUtoipa(request, requestOptions));
    }

    private async __simulateSwapUtoipa(
        request: Stonfi.DexSimulateSwapUtoipaRequest,
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.DexSimulateSwapUtoipaResponse>> {
        const {
            offer_address: offerAddress,
            ask_address: askAddress,
            units,
            slippage_tolerance: slippageTolerance,
            pool_address: poolAddress,
            referral_address: referralAddress,
            referral_fee_bps: referralFeeBps,
            dex_v2: dexV2,
            dex_version: dexVersion,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["offer_address"] = offerAddress;
        _queryParams["ask_address"] = askAddress;
        _queryParams["units"] = units;
        _queryParams["slippage_tolerance"] = slippageTolerance;
        if (poolAddress !== undefined) {
            _queryParams["pool_address"] = poolAddress;
        }

        if (referralAddress !== undefined) {
            _queryParams["referral_address"] = referralAddress;
        }

        if (referralFeeBps !== undefined) {
            _queryParams["referral_fee_bps"] = referralFeeBps;
        }

        if (dexV2 !== undefined) {
            _queryParams["dex_v2"] = dexV2?.toString() ?? null;
        }

        if (dexVersion != null) {
            if (Array.isArray(dexVersion)) {
                _queryParams["dex_version"] = dexVersion.map((item) => item);
            } else {
                _queryParams["dex_version"] = dexVersion;
            }
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/swap/simulate",
            ),
            method: "POST",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.DexSimulateSwapUtoipaResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling POST /v1/swap/simulate.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Stonfi.DexSwapStatusRequest} request
     * @param {Dex.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dex.swapStatus({
     *         router_address: "EQB3ncyBUTjZUA5EnFKR5_EnOMI9V1tTEAAPaiU71gc4TiUt",
     *         owner_address: "EQCM3B12QK1e4yZSf8GtBRT0aLMNyEsBc_DhVfRRtOEffLez",
     *         query_id: "1"
     *     })
     */
    public swapStatus(
        request: Stonfi.DexSwapStatusRequest,
        requestOptions?: Dex.RequestOptions,
    ): core.HttpResponsePromise<Stonfi.DexSwapStatusResponse> {
        return core.HttpResponsePromise.fromPromise(this.__swapStatus(request, requestOptions));
    }

    private async __swapStatus(
        request: Stonfi.DexSwapStatusRequest,
        requestOptions?: Dex.RequestOptions,
    ): Promise<core.WithRawResponse<Stonfi.DexSwapStatusResponse>> {
        const { router_address: routerAddress, owner_address: ownerAddress, query_id: queryId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["router_address"] = routerAddress;
        _queryParams["owner_address"] = ownerAddress;
        _queryParams["query_id"] = queryId;
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "v1/swap/status",
            ),
            method: "GET",
            headers: mergeHeaders(this._options?.headers, requestOptions?.headers),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Stonfi.DexSwapStatusResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.StonfiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.StonfiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.StonfiTimeoutError("Timeout exceeded when calling GET /v1/swap/status.");
            case "unknown":
                throw new errors.StonfiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }
}
